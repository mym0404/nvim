# .wezterm.lua

```lua filename="~/.wezterm.lua"
local opacity = 1
local blur = 0

local wezterm = require("wezterm")
local c = wezterm.config_builder()
local act = wezterm.action

local function getOS()
	local is_windows = os.getenv("WINDOWS")
	if is_windows ~= nil then
		return "Windows"
	end
	-- ask LuaJIT first
	if jit then
		return jit.os
	end

	local osname = ""
	-- Unix, Linux variants
	local fh, err = assert(io.popen("uname -o 2>/dev/null", "r"))
	if fh then
		osname = fh:read()
	end

	return osname or "Windows"
end

local is_windows = getOS() == "Windows"
local is_macos = getOS() == "Darwin"
local CMD = "CMD"
local CTRL = "CTRL"
local OPT = "OPT"
local SHIFT = "SHIFT"

local function setup_core()
	if is_windows then
		c.default_prog = { "wsl" }
		c.wsl_domains = { {
			name = "WSL:Ubuntu-24.04",
			distribution = "Ubuntu-24.04",
		} }
	end
	c.set_environment_variables = {
		PATH = "/opt/homebrew/bin:" .. os.getenv("PATH"),
	}
	c.initial_cols = 160
	c.initial_rows = 34

	c.use_ime = true
	c.use_dead_keys = true
	if is_macos then
		c.enable_wayland = false
	end

	c.color_scheme = "Tokyo Night"
	c.adjust_window_size_when_changing_font_size = false

	c.font = wezterm.font_with_fallback({
		{ family = "D2Coding" },
		{ family = "JetBrainsMonoHangul Nerd Font Mono" },
	})
	c.harfbuzz_features = { "calt=0", "clig=0", "liga=0" }
	c.font_size = 13

	-- Slightly transparent and blurred background
	c.front_end = "WebGpu"
	c.freetype_load_flags = "NO_HINTING"
	c.freetype_load_target = "Light"
	c.freetype_render_target = "HorizontalLcd"
	-- c.custom_block_glyphs = true
	if is_windows then
		c.cell_width = 1
		c.line_height = 1.1
	else
		c.cell_width = 1
		c.line_height = 1.15
	end

	if is_windows then
		c.dpi = 96
	end

	c.window_background_opacity = opacity
	c.macos_window_background_blur = blur
	-- Removes the title bar, leaving only the tab bar. Keeps
	-- the ability to resize by dragging the window's edges.
	-- On macOS, 'RESIZE|INTEGRATED_BUTTONS' also looks nice if
	-- you want to keep the window controls visible and integrate
	-- them into the tab bar.
	if not is_windows then
		c.window_decorations = "RESIZE"
	end
	-- Sets the font for the window frame (tab bar)
	c.window_frame = {
		font = wezterm.font({ family = "Berkeley Mono", weight = "Bold" }),
		font_size = 11,
	}
	local function segments_for_right_status(window)
		return {
			is_windows and "WSL" or "Darwin",
			-- window:active_workspace(),
			wezterm.strftime("%a %b %-d %H:%M"),
			"MJ",
		}
	end

	wezterm.on("update-status", function(window, _)
		local SOLID_LEFT_ARROW = wezterm.nerdfonts.pl_right_hard_divider
		local segments = segments_for_right_status(window)

		local color_scheme = window:effective_config().resolved_palette
		-- Note the use of wezterm.color.parse here, this returns
		-- a Color object, which comes with functionality for lightening
		-- or darkening the colour (amongst other things).
		local bg = wezterm.color.parse(color_scheme.background)
		local fg = color_scheme.foreground

		-- Each powerline segment is going to be coloured progressively
		-- darker/lighter depending on whether we're on a dark/light colour
		-- scheme. Let's establish the "from" and "to" bounds of our gradient.
		local gradient_to, gradient_from = bg, bg
		gradient_from = gradient_to:lighten(0.2)

		-- Yes, WezTerm supports creating gradients, because why not?! Although
		-- they'd usually be used for setting high fidelity gradients on your terminal's
		-- background, we'll use them here to give us a sample of the powerline segment
		-- colours we need.
		local gradient = wezterm.color.gradient(
			{
				orientation = "Horizontal",
				colors = { gradient_from, gradient_to },
			},
			#segments -- only gives us as many colours as we have segments.
		)

		-- We'll build up the elements to send to wezterm.format in this table.
		local elements = {}

		for i, seg in ipairs(segments) do
			local is_first = i == 1

			if is_first then
				table.insert(elements, { Background = { Color = "none" } })
			end
			table.insert(elements, { Foreground = { Color = gradient[i] } })
			table.insert(elements, { Text = SOLID_LEFT_ARROW })

			table.insert(elements, { Background = { Color = gradient[i] } })
			table.insert(elements, { Foreground = { Color = fg } })
			table.insert(elements, { Text = " " .. seg .. " " })
		end

		window:set_right_status(wezterm.format(elements))
	end)

	c.native_macos_fullscreen_mode = true
end

local function setup_basic_keys()
	c.keys = {
		{ key = "f", mods = CTRL .. "|" .. CMD, action = wezterm.action.ToggleFullScreen },
		-- Sends ESC + b and ESC + f sequence, which is used
		-- for telling your shell to jump back/forward.
		{
			-- When the left arrow is pressed
			key = "LeftArrow",
			-- With the "Option" key modifier held down
			mods = OPT,
			-- Perform this action, in this case - sending ESC + B
			-- to the terminal
			action = act.SendString("\x1bb"),
		},
		{
			key = "RightArrow",
			mods = OPT,
			action = act.SendString("\x1bf"),
		},
		{
			key = "w",
			mods = is_windows and CTRL or CMD,
			action = wezterm.action_callback(function(window, pane)
				local tab = pane:tab()
				local panes = tab:panes()

				if #panes >= 2 then
					window:perform_action(act.CloseCurrentPane({ confirm = false }), pane)
				else
					window:perform_action(act.CloseCurrentTab({ confirm = false }), pane)
				end
			end),
		},
		{
			key = "t",
			mods = is_windows and CTRL or CMD,
			action = act.SpawnTab("CurrentPaneDomain"),
		},
	}
end
local function setup_windows_keys()
	if not is_windows then
		return
	end

	-- c.disable_default_key_bindings = true
	-- this adds the ability to use ctrl+v to paste the system clipboard
	table.insert(c.keys, { key = "v", mods = CTRL, action = wezterm.action.PasteFrom("Clipboard") })
	-- table.insert(c.keys, { key = "c", mods = CTRL, action = wezterm.action.CopyTo("Clipboard") })

	-- Add CTRL+number keys to activate specific tabs
	for i = 1, 9 do
		table.insert(c.keys, { key = tostring(i), mods = CTRL, action = wezterm.action.ActivateTab(i - 1) })
	end

	-- There are mouse binding to mimc Windows Terminal and let you copy
	-- To copy just highlight something and right click. Simple
	local mouse_bindings = {
		{
			event = { Down = { streak = 3, button = "Left" } },
			action = wezterm.action.SelectTextAtMouseCursor("SemanticZone"),
			mods = "NONE",
		},
		{
			event = { Down = { streak = 1, button = "Right" } },
			mods = "NONE",
			action = wezterm.action_callback(function(window, pane)
				local has_selection = window:get_selection_text_for_pane(pane) ~= ""
				if has_selection then
					window:perform_action(act.CopyTo("ClipboardAndPrimarySelection"), pane)
					window:perform_action(act.ClearSelection, pane)
				else
					window:perform_action(act({ PasteFrom = "Clipboard" }), pane)
				end
			end),
		},
	}
	c.mouse_bindings = mouse_bindings
end
-- Table mapping keypresses to actions

c.colors = { foreground = "white", background = "#111111" }

c.animation_fps = 60
c.default_cursor_style = "BlinkingBar"
c.cursor_blink_rate = 400

local function regsiter_smart_splits_multiplexer()
	local w = require("wezterm")

	-- if you are *NOT* lazy-loading smart-splits.nvim (recommended)
	local function is_vim(pane)
		-- this is set by the plugin, and unset on ExitPre in Neovim
		return pane:get_user_vars().IS_NVIM == "true"
	end

	local direction_keys = {
		h = "Left",
		j = "Down",
		k = "Up",
		l = "Right",
	}

	local function split_nav(resize_or_move, key)
		return {
			key = key,
			mods = resize_or_move == "resize" and OPT or CTRL,
			action = w.action_callback(function(win, pane)
				if is_vim(pane) then
					-- pass the keys through to vim/nvim
					win:perform_action({
						SendKey = { key = key, mods = resize_or_move == "resize" and OPT or CTRL },
					}, pane)
				else
					if resize_or_move == "resize" then
						win:perform_action({ AdjustPaneSize = { direction_keys[key], 3 } }, pane)
					else
						win:perform_action({ ActivatePaneDirection = direction_keys[key] }, pane)
					end
				end
			end),
		}
	end

	table.insert(c.keys, split_nav("move", "h"))
	table.insert(c.keys, split_nav("move", "j"))
	table.insert(c.keys, split_nav("move", "k"))
	table.insert(c.keys, split_nav("move", "l"))
	table.insert(c.keys, split_nav("resize", "h"))
	table.insert(c.keys, split_nav("resize", "j"))
	table.insert(c.keys, split_nav("resize", "k"))
	table.insert(c.keys, split_nav("resize", "l"))
end

local function register_split_multiplexing()
	local w = require("wezterm")

	-- if you are *NOT* lazy-loading smart-splits.nvim (recommended)
	local function is_vim(pane)
		-- this is set by the plugin, and unset on ExitPre in Neovim
		return pane:get_user_vars().IS_NVIM == "true"
	end

	local function split_nav(is_horizontal)
		local mods = (is_windows and CTRL or CMD) .. (is_horizontal and "|" .. OPT or "")
		return {
			key = "0",
			mods = mods,
			action = w.action_callback(function(win, pane)
				-- if is_vim(pane) then
				-- 	-- pass the keys through to vim/nvim
				-- 	win:perform_action({
				-- 		SendKey = { key = "0", mods = mods },
				-- 	}, pane)

				-- else
				if is_horizontal then
					win:perform_action(act.SplitHorizontal({ domain = "CurrentPaneDomain" }), pane)
				else
					win:perform_action(act.SplitVertical({ domain = "CurrentPaneDomain" }), pane)
				end
				-- end
			end),
		}
	end

	table.insert(c.keys, split_nav(true))
	table.insert(c.keys, split_nav(false))
end
setup_basic_keys()
setup_core()
setup_windows_keys()
regsiter_smart_splits_multiplexer()
register_split_multiplexing()

return c
```
